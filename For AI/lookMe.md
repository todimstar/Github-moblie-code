小鸡出好了《小鸡的排列构造》一题，却发现自己不会写复杂度正确的checker（一定程度上是真的）！小鸡只好寻求你的帮助。
具体来说，对于给定的长为 
𝑛
n 的排列 
𝑝
p，你需要判断 
𝑚
m 个问题，其中第 
𝑖
i 个问题形如：
∙
 
∙对于给定的 
𝑙
𝑖
,
𝑟
𝑖
,
𝑐
𝑖
l 
i
​
 ,r 
i
​
 ,c 
i
​
 ，满足 
𝑙
𝑖
≤
𝑐
𝑖
≤
𝑟
𝑖
l 
i
​
 ≤c 
i
​
 ≤r 
i
​
  且 
𝑙
𝑖
≠
𝑟
𝑖
l 
i
​
  

​
 =r 
i
​
 ，你需要输出将子区间 
[
𝑙
𝑖
,
𝑟
𝑖
]
[l 
i
​
 ,r 
i
​
 ] 中的元素从小到大排序后，原来位置 
𝑐
𝑖
c 
i
​
  处的数字移动到了哪里。
这 
𝑚
m 次询问是独立的，你可以理解为每次询问并不会真的改变原数组。

长度为 
𝑛
n 的排列是由 
1
∼
𝑛
1∼n 这 
𝑛
n 个整数、按任意顺序组成的数组，其中每个整数恰好出现一次。例如，
{
2
,
3
,
1
,
5
,
4
}
{2,3,1,5,4} 是一个长度为 
5
5 的排列，而 
{
1
,
2
,
2
}
{1,2,2} 和 
{
1
,
3
,
4
}
{1,3,4} 都不是排列，因为前者存在重复元素，后者包含了超出范围的数。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数 
T(1≤T≤1e5
 ) 代表数据组数，每组测试数据描述如下：

第一行输入两个正整数n,m(3≤n≤1e5; 1≤m≤3×1e5 ) 代表排列的长度、问题的数量。
第二行输入 
𝑛
n 个不同的正整数 
p 
1
 ,p 
2
 ,…,p 
n
 (1≤p i≤n) 代表给定的排列。
此后 
m 行，每行输入三个正整数 
𝑙
,
𝑟
,
𝑐
(
1
≤
𝑙
≤
𝑐
≤
𝑟
≤
𝑛
;
 
𝑙
≠
𝑟
)
代表一次询问。

除此之外，保证单个测试文件的 
𝑛
之和不超过 
3
×
1e5
 ，
𝑚 之和不超过 
3×1e5
 。
输出描述:
对于每一组测试数据，在一行上输出一个整数，代表第 
𝑖次询问的答案，即排序后原来位置 𝑐𝑖处的数字移动到的位置的下标。
示例1
输入
复制
2
5 3
1 4 2 3 5
3 5 4
1 3 2
1 5 4
9 5
1 4 9 2 8 7 3 5 6
1 7 4
2 9 2
3 4 4
5 9 7
1 9 7
输出
复制
4
3
3
2
4
3
5
3
对于这题，题解如下，但是我不知道树状数组为何物，我不能理解题解，请你根据这题教我所需的树状数组知识，使我学以致用快速掌握
题解：本题预期的做法是使用离线将查询排序的技巧，使用树状数组进行维
护。
我们举一个例子说明该做法的思路，例如输入的数组 p 为 [1, 3, 2, 4, 5]，查询分别为 [1, 5, 2] 和 [2, 5, 4]，我们发现 [1, 5, 2] 查询相当于在问：[1, 5] 区间里有多少个小于等于 p2 的数字？（因为这些数的个数能得出排序后 p2 的位置）。
于是我们可以维护一个初始全 0 的树状数组，按照 pi 从小到大给树状数组的对应位置 +1，也就是在上述例子中，树状数组维护的原数组依次是：状态 1：[1, 0, 0, 0, 0] 状态 2：[1, 0, 1, 0, 0] 状态 3：[1, 1, 1, 0, 0] 状态 4：[1, 1, 1, 1, 0] 状态 5：[1, 1, 1, 1, 1]
这样询问 [1, 5, 2] 其实是在对状态 2 的数组求 [1, 5] 区间的和，使用树状数组可以做到；询问 [2, 5, 4] 其实是在对状态 4 的数组求 [2, 5] 区间的和，使用树状数组可以做到。
因此，像上述过程一样，把所有 [l, r, c] 询问按照 p[c] 从小到大排序，树状数组维护上述过程即可，复杂度 O(n log n)。其它做法，例如主席树，没有刻意去卡。但一些复杂度 O(n log2 n)、O(n
√
n) 的做法和未关同步流 cin 的做法是比较容易 TLE 的。